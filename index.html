<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Monedio</title>
    <script src="https://cdn.jsdelivr.net/npm/@multisynq/client@latest/bundled/multisynq-client.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #87CEEB;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: #90EE90;
            cursor: none;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #perfStats {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div>Size: <span id="sizeDisplay">10</span></div>
        <div>Players: <span id="playersCount">1</span></div>
    </div>
    <div id="perfStats">
        <div>FPS: <span id="fpsDisplay">--</span></div>
        <div>Frame: <span id="frameTimeDisplay">--</span>ms</div>
        <div>Avg: <span id="avgFrameDisplay">--</span>ms</div>
        <div>Min/Max: <span id="minMaxDisplay">--/--</span>ms</div>
        <div>Latency: <span id="latencyDisplay">--</span>ms</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const API_KEY = "2GzxJfKu10qeIJcl0FsTY5AbhgXQj2ZgaXJhm6jHbK";
        const CANVAS_WIDTH = window.innerWidth;
        const CANVAS_HEIGHT = window.innerHeight;
        const WORLD_WIDTH = 2000;
        const WORLD_HEIGHT = 2000;

        // Performance Stats Class
        class PerformanceStats {
            constructor() {
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.frameStartTime = performance.now();
                this.frameTimes = [];
                this.maxSamples = 60; // Keep last 60 frame times
                this.lastFpsUpdate = 0;
                this.fps = 0;
                this.avgFrameTime = 0;
                this.minFrameTime = Infinity;
                this.maxFrameTime = 0;
                this.inputLatency = 0;
                this.lastInputTime = 0;

                // DOM elements
                this.fpsDisplay = document.getElementById('fpsDisplay');
                this.frameTimeDisplay = document.getElementById('frameTimeDisplay');
                this.avgFrameDisplay = document.getElementById('avgFrameDisplay');
                this.minMaxDisplay = document.getElementById('minMaxDisplay');
                this.latencyDisplay = document.getElementById('latencyDisplay');
            }

            startFrame() {
                this.frameStartTime = performance.now();
            }

            endFrame() {
                const now = performance.now();
                const frameTime = now - this.frameStartTime;
                
                // Add frame time to our sample array
                this.frameTimes.push(frameTime);
                if (this.frameTimes.length > this.maxSamples) {
                    this.frameTimes.shift();
                }

                // Update min/max
                this.minFrameTime = Math.min(this.minFrameTime, frameTime);
                this.maxFrameTime = Math.max(this.maxFrameTime, frameTime);

                this.frameCount++;

                // Update FPS and stats every 250ms
                if (now - this.lastFpsUpdate > 250) {
                    this.updateStats(now);
                    this.lastFpsUpdate = now;
                }
            }

            updateStats(now) {
                // Calculate FPS
                const timeDelta = now - this.lastTime;
                if (timeDelta > 0) {
                    this.fps = Math.round((this.frameCount * 1000) / timeDelta);
                }

                // Calculate average frame time
                if (this.frameTimes.length > 0) {
                    this.avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
                }

                // Reset counters
                this.frameCount = 0;
                this.lastTime = now;

                // Update UI
                this.updateDisplay();
            }

            updateDisplay() {
                this.fpsDisplay.textContent = this.fps;
                this.frameTimeDisplay.textContent = this.frameTimes.length > 0 ? 
                    this.frameTimes[this.frameTimes.length - 1].toFixed(1) : '--';
                this.avgFrameDisplay.textContent = this.avgFrameTime.toFixed(1);
                this.minMaxDisplay.textContent = 
                    `${this.minFrameTime === Infinity ? '--' : this.minFrameTime.toFixed(1)}/${this.maxFrameTime.toFixed(1)}`;
                this.latencyDisplay.textContent = this.inputLatency.toFixed(1);

                // Color code FPS based on performance
                if (this.fps >= 55) {
                    this.fpsDisplay.style.color = '#4CAF50'; // Green
                } else if (this.fps >= 30) {
                    this.fpsDisplay.style.color = '#FF9800'; // Orange  
                } else {
                    this.fpsDisplay.style.color = '#F44336'; // Red
                }
            }

            recordInputLatency() {
                this.lastInputTime = performance.now();
            }

            measureInputLatency() {
                if (this.lastInputTime > 0) {
                    this.inputLatency = performance.now() - this.lastInputTime;
                    this.lastInputTime = 0;
                }
            }

            reset() {
                this.minFrameTime = Infinity;
                this.maxFrameTime = 0;
                this.frameTimes = [];
            }
        }

        // Game Model - handles all game logic and state
        class MopeGameModel extends Multisynq.Model {
            init() {
                // Game state
                this.players = new Map();
                this.food = new Map();
                this.nextFoodId = 0;
                
                // Global throttling
                this.lastGlobalGameStateUpdate = 0;

                // Subscribe to player events
                this.subscribe(this.sessionId, "playerJoin", this.handlePlayerJoin);
                this.subscribe(this.sessionId, "playerMove", this.handlePlayerMove);
                this.subscribe(this.sessionId, "playerLeave", this.handlePlayerLeave);
                this.subscribe(this.sessionId, "foodEaten", this.handleFoodEaten);

                // Spawn initial food
                this.spawnFood(50);

                // Start food spawning loop
                this.future(1000, () => this.spawnFoodLoop());

                // Start server-side movement update loop
                this.future(50, () => this.updateServerMovement());

                // Periodic broadcast removed - game states sent on events only

                console.log("Game model initialized");
            }

            handlePlayerJoin(data) {
                const playerId = data.playerId;
                this.players.set(playerId, {
                    id: playerId,
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    targetX: Math.random() * WORLD_WIDTH,
                    targetY: Math.random() * WORLD_HEIGHT,
                    size: 15,
                    color: this.getRandomColor()
                });

                console.log("Player joined:", playerId);
                this.publishGameStateThrottled();
            }

            handlePlayerMove(data) {
                const player = this.players.get(data.playerId);
                if (player) {
                    // Use client's predicted position if reasonable, otherwise interpolate
                    if (data.x && data.y) {
                        const dx = data.x - player.x;
                        const dy = data.y - player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // If client position is reasonable, use it
                        if (distance < 100) {
                            player.x = data.x;
                            player.y = data.y;
                        }
                    }

                    // Store target for server-side movement
                    player.targetX = data.targetX;
                    player.targetY = data.targetY;

                    // Keep player in bounds
                    player.x = Math.max(player.size, Math.min(WORLD_WIDTH - player.size, player.x));
                    player.y = Math.max(player.size, Math.min(WORLD_HEIGHT - player.size, player.y));

                    // Check food collisions
                    this.checkFoodCollisions(player);
                }

                // Use global throttled update
                this.publishGameStateThrottled();
            }

            handlePlayerLeave(data) {
                this.players.delete(data.playerId);
                this.publishGameStateThrottled();
            }

            handleFoodEaten(data) {
                const foodId = data.foodId;
                const playerId = data.playerId;
                const player = this.players.get(playerId);

                // Verify the food still exists and player is close enough
                if (player && this.food.has(foodId)) {
                    const food = this.food.get(foodId);
                    const dx = player.x - food.x;
                    const dy = player.y - food.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Double-check collision on server side
                    if (distance < player.size + food.size) {
                        this.food.delete(foodId);
                        player.size += 1;

                        // Spawn new food to replace eaten one
                        this.spawnFood(1);
                        console.log("Food eaten by player:", playerId, "Food ID:", foodId);
                        
                        // Send immediate update for food consumption
                        this.publishGameStateThrottled();
                    }
                }
            }

            checkFoodCollisions(player) {
                for (let [foodId, food] of this.food.entries()) {
                    const dx = player.x - food.x;
                    const dy = player.y - food.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < player.size + food.size) {
                        // Player eats food
                        this.food.delete(foodId);
                        player.size += 1;

                        // Spawn new food to replace eaten one
                        this.spawnFood(1);
                        break;
                    }
                }
            }

            spawnFood(count) {
                for (let i = 0; i < count; i++) {
                    const foodId = this.nextFoodId++;
                    this.food.set(foodId, {
                        id: foodId,
                        x: Math.random() * WORLD_WIDTH,
                        y: Math.random() * WORLD_HEIGHT,
                        size: 4,
                        color: this.getRandomFoodColor()
                    });
                }
            }

            spawnFoodLoop() {
                // Maintain food count
                if (this.food.size < 40) {
                    this.spawnFood(5);
                    this.publishGameStateThrottled();
                }

                // Schedule next spawn
                this.future(2000, () => this.spawnFoodLoop());
            }

            updateServerMovement() {
                // Update all players' positions on server-side
                for (let [playerId, player] of this.players.entries()) {
                    if (player.targetX !== undefined && player.targetY !== undefined) {
                        const dx = player.targetX - player.x;
                        const dy = player.targetY - player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 2) {
                            const moveSpeed = Math.max(1, 5 - player.size * 0.1);
                            player.x += (dx / distance) * moveSpeed * 0.5; // Slower server movement
                            player.y += (dy / distance) * moveSpeed * 0.5;

                            // Keep player in bounds
                            player.x = Math.max(player.size, Math.min(WORLD_WIDTH - player.size, player.x));
                            player.y = Math.max(player.size, Math.min(WORLD_HEIGHT - player.size, player.y));
                        }
                    }
                }

                // Schedule next update
                this.future(50, () => this.updateServerMovement()); // 20Hz server updates
            }

            broadcastGameState() {
                this.publishGameStateThrottled();
                this.future(200, () => this.broadcastGameState()); // Broadcast every 200ms
            }

            publishGameStateThrottled() {
                const now = Date.now();
                if (now - this.lastGlobalGameStateUpdate > 200) { // Max 5 updates per second globally
                    this.lastGlobalGameStateUpdate = now;
                    this.publish(this.sessionId, "gameStateUpdate", this.getGameState());
                }
            }

            getGameState() {
                return {
                    players: Array.from(this.players.values()),
                    food: Array.from(this.food.values())
                };
            }

            getRandomColor() {
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FCEA2B', '#FF9FF3'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            getRandomFoodColor() {
                const colors = ['#FF4757', '#5352ED', '#00D2D3', '#FF9F43', '#6C5CE7'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
        }

        // Game View - handles rendering and input
        class MopeGameView extends Multisynq.View {
            constructor(model) {
                super(model);

                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.playerId = this.sessionId + '_' + Math.random().toString(36).substr(2, 9);

                // Set canvas size
                this.canvas.width = CANVAS_WIDTH;
                this.canvas.height = CANVAS_HEIGHT;

                // Game state
                this.gameState = { players: [], food: [] };
                this.camera = { x: 0, y: 0 };
                this.mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };

                // Local food state for client-side prediction
                this.localFoodState = new Map(); // Track which food items are locally "eaten"
                this.predictedEatenFood = new Set(); // Food IDs that we predict are eaten

                // Initialize performance stats
                this.perfStats = new PerformanceStats();

                // Client-side prediction state
                this.localPlayer = {
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    size: 15,
                    color: '#FF6B6B',
                    targetX: 0,
                    targetY: 0
                };

                // Network sync timing
                this.lastNetworkSync = 0;
                this.networkSyncInterval = 100; // Send position every 100ms (10Hz)

                // Subscribe to game updates
                this.subscribe(this.sessionId, "gameStateUpdate", (state) => this.updateGameState(state));

                // Setup input
                this.setupInput();

                // Start render loop - using requestAnimationFrame for smooth 60fps
                this.startRenderLoop();

                // Start network sync loop - separate from rendering
                this.startNetworkLoop();

                // Join the game
                this.publish(this.sessionId, "playerJoin", { playerId: this.playerId });

                console.log("Game view initialized, player ID:", this.playerId);
            }

            setupInput() {
                // Mouse movement - just update target, don't send to network immediately
                this.canvas.addEventListener('mousemove', (e) => {
                    // Record input time for latency measurement
                    this.perfStats.recordInputLatency();
                    
                    const rect = this.canvas.getBoundingClientRect();
                    this.mousePos.x = e.clientX - rect.left;
                    this.mousePos.y = e.clientY - rect.top;

                    // Update local target immediately for responsiveness
                    this.localPlayer.targetX = this.mousePos.x + this.camera.x;
                    this.localPlayer.targetY = this.mousePos.y + this.camera.y;
                });

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }

            startRenderLoop() {
                const renderFrame = () => {
                    this.updateLocalPlayer(); // Update local player position
                    this.render(); // Render everything
                    requestAnimationFrame(renderFrame);
                };
                renderFrame();
            }

            startNetworkLoop() {
                setInterval(() => {
                    this.sendNetworkUpdate();
                }, this.networkSyncInterval);
            }

            updateLocalPlayer() {
                // Smooth movement towards mouse target (client-side prediction)
                const dx = this.localPlayer.targetX - this.localPlayer.x;
                const dy = this.localPlayer.targetY - this.localPlayer.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    const moveSpeed = Math.max(3, 8 - this.localPlayer.size * 0.1);
                    this.localPlayer.x += (dx / distance) * moveSpeed;
                    this.localPlayer.y += (dy / distance) * moveSpeed;

                    // Keep player in bounds
                    this.localPlayer.x = Math.max(this.localPlayer.size, Math.min(WORLD_WIDTH - this.localPlayer.size, this.localPlayer.x));
                    this.localPlayer.y = Math.max(this.localPlayer.size, Math.min(WORLD_HEIGHT - this.localPlayer.size, this.localPlayer.y));
                }

                // Client-side food collision detection for immediate feedback
                this.checkLocalFoodCollisions();

                // Update camera to follow local player
                this.camera.x = this.localPlayer.x - CANVAS_WIDTH / 2;
                this.camera.y = this.localPlayer.y - CANVAS_HEIGHT / 2;
                this.camera.x = Math.max(0, Math.min(WORLD_WIDTH - CANVAS_WIDTH, this.camera.x));
                this.camera.y = Math.max(0, Math.min(WORLD_HEIGHT - CANVAS_HEIGHT, this.camera.y));
            }

            checkLocalFoodCollisions() {
                // Check collisions with food items that aren't already predicted as eaten
                this.gameState.food.forEach(food => {
                    if (!this.predictedEatenFood.has(food.id)) {
                        const dx = this.localPlayer.x - food.x;
                        const dy = this.localPlayer.y - food.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.localPlayer.size + food.size) {
                            // Predict food is eaten - hide it immediately
                            this.predictedEatenFood.add(food.id);
                            
                            // Predict size increase
                            this.localPlayer.size += 1;
                            
                            // Send food eaten event to server
                            this.publish(this.sessionId, "foodEaten", {
                                playerId: this.playerId,
                                foodId: food.id,
                                playerX: this.localPlayer.x,
                                playerY: this.localPlayer.y
                            });

                            console.log("Food eaten locally:", food.id);
                        }
                    }
                });
            }

            sendNetworkUpdate() {
                // Only send network updates periodically, not on every frame
                const now = Date.now();
                if (now - this.lastNetworkSync >= this.networkSyncInterval) {
                    this.lastNetworkSync = now;
                    
                    // Send current position and target to server
                    this.publish(this.sessionId, "playerMove", {
                        playerId: this.playerId,
                        x: this.localPlayer.x,
                        y: this.localPlayer.y,
                        targetX: this.localPlayer.targetX,
                        targetY: this.localPlayer.targetY
                    });
                }
            }

            updateGameState(state) {
                // Reconcile food predictions with server state
                const serverFoodIds = new Set(state.food.map(f => f.id));
                
                // Check our predictions against server reality
                for (let predictedFoodId of this.predictedEatenFood) {
                    if (serverFoodIds.has(predictedFoodId)) {
                        // Server still has this food - our prediction was wrong, remove from predicted set
                        this.predictedEatenFood.delete(predictedFoodId);
                        console.log("Food prediction corrected - food still exists:", predictedFoodId);
                    }
                    // If server doesn't have the food, our prediction was correct - keep it in the set
                }

                // Update other players with server data
                this.gameState = state;

                // Find our player in server data and reconcile if needed
                const serverPlayer = state.players.find(p => p.id === this.playerId);
                if (serverPlayer) {
                    // Simple reconciliation - if too far from server, adjust
                    const dx = serverPlayer.x - this.localPlayer.x;
                    const dy = serverPlayer.y - this.localPlayer.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 50) { // If too far from server position, snap back
                        this.localPlayer.x = serverPlayer.x;
                        this.localPlayer.y = serverPlayer.y;
                    }

                    // Always sync size from server (authoritative for food consumption)
                    this.localPlayer.size = serverPlayer.size;
                    this.localPlayer.color = serverPlayer.color;

                    // Update UI
                    document.getElementById('sizeDisplay').textContent = Math.floor(serverPlayer.size);
                }

                document.getElementById('playersCount').textContent = state.players.length;
            }

            render() {
                // Start performance measurement
                this.perfStats.startFrame();
                
                // Measure input latency
                this.perfStats.measureInputLatency();

                // Clear canvas
                this.ctx.fillStyle = '#90EE90';
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Save context for camera transform
                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                // Draw food
                this.gameState.food.forEach(food => {
                    // Skip food that we predict has been eaten
                    if (!this.predictedEatenFood.has(food.id)) {
                        this.ctx.fillStyle = food.color;
                        this.ctx.beginPath();
                        this.ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });

                // Draw other players (from server data)
                this.gameState.players.forEach(player => {
                    if (player.id !== this.playerId) { // Don't draw our own player from server data
                        this.ctx.fillStyle = player.color;
                        this.ctx.beginPath();
                        this.ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Player outline
                        this.ctx.strokeStyle = '#000';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                });

                // Draw our own player from local prediction (most responsive)
                this.ctx.fillStyle = this.localPlayer.color;
                this.ctx.beginPath();
                this.ctx.arc(this.localPlayer.x, this.localPlayer.y, this.localPlayer.size, 0, Math.PI * 2);
                this.ctx.fill();

                // Highlight our own player
                this.ctx.strokeStyle = '#FFF';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();

                // Draw black outline
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                // Restore context
                this.ctx.restore();

                // Draw grid for reference (optional)
                this.drawGrid();

                // End performance measurement
                this.perfStats.endFrame();
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                this.ctx.lineWidth = 1;

                const gridSize = 100;
                const startX = -(this.camera.x % gridSize);
                const startY = -(this.camera.y % gridSize);

                for (let x = startX; x < CANVAS_WIDTH; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, CANVAS_HEIGHT);
                    this.ctx.stroke();
                }

                for (let y = startY; y < CANVAS_HEIGHT; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(CANVAS_WIDTH, y);
                    this.ctx.stroke();
                }
            }
        }

        // Start the game
        MopeGameModel.register("MopeGameModel");
        Multisynq.Session.join({
            apiKey: API_KEY,
            appId: "com.mopeio.clone",
            model: MopeGameModel,
            view: MopeGameView,
            name: Multisynq.App.autoSession(),
            password: Multisynq.App.autoPassword()
        }).then(session => {
            console.log("Joined game session:", session.id);
            Multisynq.App.makeWidgetDock();
        }).catch(error => {
            console.error("Failed to join session:", error);
        });
    </script>
</body>

</html>